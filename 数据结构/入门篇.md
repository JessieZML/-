[TOC]



# 入门

## 01 为什么要学习数据结构与算法

学习的重点在什么地方？

​    数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。在学习数据结构和算法的过程中，要学习它的「来历」、「自身的特点」、「适合解决的问题」以及「实际的应用场景」。

- 数据结构和算法学习的精髓-复杂度分析
- 最常用的、最基础的数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树
- 最常用的算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法  



重点：

- 直接好处是能够有写出性能更优的代码。
- 算法，是一种解决问题的思路和方法，有机会应用到生活和事业的其他方面。
- 长期来看，大脑思考能力是个人最重要的核心竞争力，而算法是为数不多的能够有效训练大脑思考能力的途径之一。



## 02 学什么 & 怎么学

### 数据结构和算法是什么？

从广义上讲：

- 数据结构：一组数据的存储结构
- 算法：操作数据的一组方法

从狭义上讲：

- 指一些著名的数据结构和算法，如：队列、栈、堆、二分查找、动态规划等

两者关系：

- 二者相辅相成
- 数据结构为算法服务，算法要作用在特定的数据结构之上
- 数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的

> 例如：数组具有随机访问的特点，二分查找算法需要用数组来存储数据。但如果选择链表，二分查找就无法工作了，因为链表不支持随机访问。

### 学习重点

1. 掌握最重要的概念（精髓）——复杂度分析

数据结构和算法的目的：如何更快、更省地存储和处理数据的问题

> 如何考量效率和资源消耗的方法：复杂度分析

2. 10 个数据结构：**数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树**；10 个算法：**递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法**。

![](./images/1_1.jpg)

3. 学习要点：

- 要学习 **“来历” “自身的特点” “适合解决的问题” “实际的应用场景”**
- 不要被动地记忆，要多辩证地思考，多问为什么

### 怎么学

- 边学边练，适度刷题
  - 每周花时间把学习内容全都自己**写出来，代码实现一遍**，可以适度刷题，但不要浪费太多时间在刷题上。学习目的是**掌握，然后应用**。学完这门课足够应对国内公司的技术面试。
- 多问、多思考、多互动
- 打怪升级学习法
  - 在学习中，给自己列一个切实可行的目标，就像打怪升级一样
- 知识需要沉淀，不要想试图一下子掌握所有
  - 学习知识的过程就是反复迭代、不断沉淀的过程



## 03 复杂度分析（上）

> 复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半

### 为什么要学习复杂度分析

事前统计法 —— 把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小 —— 有非常大的局限性：

1. 测试结果非常依赖测试环境
2. 测试结果受数据规模的影响很大

所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法 —— 时间、空间复杂度分析法

### 大O复杂度表示法

例1：估算下列代码的执行时间

```c
int cal(int n) { 
	int sum = 0;          // 1 * unit_time
	int i = 1;            // 1 * unit_time
	for (; i <= n; ++i) { // n * unit_time
		sum = sum + i;    // n * unit_time
	} 
	return sum; 
}

// 总的执行时间：(2n+2) * unit_time
```

由上例可以看出来，所有代码的执行时间 T(n) 与每行代码的执行次数成正比。

例2：

```c
 int cal(int n) {
   int sum = 0;             // 1
   int i = 1;               // 1
   int j = 1;               // 1
   for (; i <= n; ++i) {    // n
     j = 1;                 // n
     for (; j <= n; ++j) {  // n^2
       sum = sum +  i * j;  // n^2
     }
   }
 }

// 总的执行时间：(2n^2+2n+3) * unit_time
```

通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，**所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比**。

总结公式为：
$$
T(n) = O(f(n))
$$
其中：

- $T(n)$ 表示代码执行的时间；
- $n$ 表示数据的规模大小；
- $f(n)$ 表示每行代码执行的次数总和；
- $O$ 表示代码的执行时间$T(n)$与$f(n)$成正比

所以，例1中$T(n) = O(2n+2)$，例2中$T(n) = O(2n2+2n+3)$，这就是**大 O 时间复杂度表示法**。

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，所以，也叫作**渐进时间复杂度**（asymptotic time complexity），简称**时间复杂度**。



### 时间复杂度分析

方法：

1. 只关注循环执行次数最多的一段代码
2. 加法法则：总的时间复杂度就等于量级最大的那段代码的时间复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积



### 常见的复杂度量级

![1_2](.\images\1_2.jpg)

将上述复杂度量级可以粗略分为两类：

- 多项式量级
- 非多项式量级：$O(2^n)$ 和 $O(n!)$

时间复杂度为**非多项式量级**的算法问题：NP问题（Non-Deterministic Polynomial, 非确定多项式）。

NP问题是非常低效的算法 —— 当 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。



### 时间复杂度排序

![1_3](.\images\1_3.jpg)



### 几种常见的多项式时间复杂度

#### 1. $O(1)$

$O(1)$只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。

比如这段代码，即便有 3 行，它的时间复杂度也是 $O(1)$，而不是 $O(3)$。

```C
 int i = 8;
 int j = 6;
 int sum = i + j;
```

**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是$Ο(1)$。**



#### 2. $O(logn)$ & $O(nlogn)$

```c
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

对于上述代码，i 从1开始取值，每次乘 2，当大于 n 时，终止循环。

则 i 的值为：$2^0, 2^1, 2^2, ..., 2^k, ..., 2^x=n $

所以 x 的值即为这段代码的执行次数。通过求解 $2^x = n$ 可得： $x = log_2 n$

从而这段代码的时间复杂度即为 $O(log_2 n)$



实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 $O(logn)$

因为：

- 对数之间是可以互相转换的，$log_3n = log_32 * log_2n$
- 所以 $O(log3n) = O(C*log2n)$，其中 $C=log_32$ 是一个常量。

- 基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 $O(C*f(n)) = O(f(n))$。
- 所以，$O(log_2n) = O(log_3n)$。

因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 $O(logn)$。



#### 3. $O(m+n)$ & $O(m*n)$

代码的复杂度由两个数据的规模来决定的情况：

```c
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 $O(m+n)$。

针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：$T_1(m) + T_2(n) = O(f(m) + g(n))$。

但是乘法法则继续有效：$T_1(m)*T_2(n) = O(f(m) * f(n))$



### 空间复杂度分析

类比时间复杂度的定义，空间复杂度全称就是**渐进空间复杂度**（asymptotic space complexity），表示**算法的存储空间与数据规模之间的增长关系**。

